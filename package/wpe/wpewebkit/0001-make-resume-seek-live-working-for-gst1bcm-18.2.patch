diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
index a688bafdd1c..19a9b98cee1 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.cpp
@@ -349,47 +349,6 @@ void MediaPlayerPrivateGStreamer::commitLoad()
     updateStates();
 }
 
-#if PLATFORM(BCM_NEXUS)
-// utility function for bcm nexus seek functionality
-static void findDecoders(GstElement *element, GstElement **videoDecoder, GstElement **audioDecoder)
-{
-    if (!(videoDecoder || audioDecoder))
-        return;
-
-    if (GST_IS_BIN(element)) {
-        GstIterator* it = gst_bin_iterate_elements(GST_BIN(element));
-        GValue item = G_VALUE_INIT;
-        bool done = false;
-        while (!done) {
-            switch (gst_iterator_next(it, &item)) {
-                case GST_ITERATOR_OK:
-                {
-                    GstElement *next = GST_ELEMENT(g_value_get_object(&item));
-                    findDecoders(next, videoDecoder, audioDecoder);
-                    done = (!((videoDecoder && !*videoDecoder) || (audioDecoder && !*audioDecoder)));
-                    g_value_reset (&item);
-                    break;
-                }
-                case GST_ITERATOR_RESYNC:
-                    gst_iterator_resync (it);
-                    break;
-                case GST_ITERATOR_ERROR:
-                case GST_ITERATOR_DONE:
-                    done = true;
-                    break;
-            }
-        }
-        g_value_unset (&item);
-        gst_iterator_free(it);
-    } else if (videoDecoder && (GST_IS_VIDEO_DECODER(element) || g_str_has_suffix(G_OBJECT_TYPE_NAME(G_OBJECT(element)), "VideoDecoder")))
-        *videoDecoder = element;
-    else if (audioDecoder && (GST_IS_AUDIO_DECODER(element) || g_str_has_suffix(G_OBJECT_TYPE_NAME(G_OBJECT(element)), "AudioDecoder")))
-        *audioDecoder = element;
-    return;
-}
-#endif
-
-
 MediaTime MediaPlayerPrivateGStreamer::playbackPosition() const
 {
 
@@ -411,8 +370,6 @@ MediaTime MediaPlayerPrivateGStreamer::playbackPosition() const
     if (m_lastQueryTime && (now - m_lastQueryTime.value()) < positionCacheThreshold && m_cachedPosition.isValid())
         return m_cachedPosition;
 
-    m_lastQueryTime = now;
-
     // Position is only available if no async state change is going on and the state is either paused or playing.
     gint64 position = GST_CLOCK_TIME_NONE;
     GstElement* positionElement = nullptr;
@@ -430,32 +387,79 @@ MediaTime MediaPlayerPrivateGStreamer::playbackPosition() const
     // Implement getting pts time from broadcom decoder directly for seek functionality.
     // In some cases one stream (audio or video) is shorter than the other and its position doesn't
     // increase anymore. We need to query both decoders (if available) and choose the highest position.
-    GstElement* videoDecoder = nullptr;
-    GstElement* audioDecoder = nullptr;
     GstClockTime videoPosition = GST_CLOCK_TIME_NONE;
     GstClockTime audioPosition = GST_CLOCK_TIME_NONE;
 
-    findDecoders(m_pipeline.get(), &videoDecoder, &audioDecoder);
+     if (!m_audioDecoder) {
+        if (!m_videoDecoder) {
+            GstElement *videoDecoder = nullptr;
+            if (!(m_videoDecoder)) {
+                m_videoDecoder = getElement(m_pipeline.get(), ElementType::DECODER, MediaType::VIDEO);
+            }
 
-    GST_TRACE("videoDecoder: %s, audioDecoder: %s", videoDecoder ? GST_ELEMENT_NAME(videoDecoder) : "null", audioDecoder ? GST_ELEMENT_NAME(audioDecoder) : "null");
+            if (!m_videoDecoder) {
+                m_lastQueryTime = now;
+                return MediaTime::zeroTime();
+            }
+        }
 
-    if (!(videoDecoder || audioDecoder))
-        return MediaTime::zeroTime();
-    if (videoDecoder && gst_element_query(videoDecoder, query))
-        gst_query_parse_position(query, 0, (gint64*)&videoPosition);
-    if (audioDecoder) {
-        g_object_set(audioDecoder, "use-audio-position", true, nullptr);
-        if (gst_element_query(audioDecoder, query))
-            gst_query_parse_position(query, 0, (gint64*)&audioPosition);
-    }
-    if (videoPosition == GST_CLOCK_TIME_NONE)
-        videoPosition = 0;
-    if (audioPosition == GST_CLOCK_TIME_NONE)
-        audioPosition = 0;
+        if (gst_element_query(m_videoDecoder, query)) {
+            gst_query_parse_position(query, 0, (gint64*)&videoPosition);
+        }
+
+        if (videoPosition == GST_CLOCK_TIME_NONE)
+            videoPosition = 0;
+
+
+        if (!(m_seeking || m_paused)) {
+            if (m_cachedPosition.isValid() && videoPosition != 0 ) {
+                if ((static_cast<GstClockTime>(videoPosition) > toGstClockTime(m_cachedPosition)) || m_cachedPosition == MediaTime::zeroTime()) {
+                    // Always video position.
+                    position = videoPosition;
+                } else if ((static_cast<GstClockTime>(videoPosition) == toGstClockTime(m_cachedPosition)) &&
+                    ((m_lastQueryTime && (now - m_lastQueryTime.value()) < 2_s))) { // TODO: 2 seconds for decision, are there any other ways to switch audio position?
+                    // If the reported position is same for 2 seconds, try audio position.
+                    gst_query_unref(query);
+                    return m_cachedPosition;
+                } else if (m_cachedPosition == m_seekTime) {
+                    // When seeking is not completed, report video position.
+                    if (videoPosition > 0)
+                        position = videoPosition;
+                } else {
+                    GST_INFO("Switch to audio position.");
+                    GstElement *audioDecoder = nullptr;
+                    if (!(m_audioDecoder)) {
+                        m_audioDecoder = getElement(m_pipeline.get(), ElementType::DECODER, MediaType::AUDIO);
+                    }
+                    if (!m_audioDecoder) {
+                        m_lastQueryTime = now;
+                        gst_query_unref(query);
+                        return m_cachedPosition;
+                    }
+                    g_object_set(m_audioDecoder, "use-audio-position", true, nullptr);
+                    if (gst_element_query(m_audioDecoder, query))
+                        gst_query_parse_position(query, 0, (gint64*)&audioPosition);
+
+                    if (audioPosition == GST_CLOCK_TIME_NONE)
+                        audioPosition = 0;
+
+                    position = audioPosition;
+                }
+            }
+        } else {
+            // Report cached position in case of paused or seeking.
+            position = toGstClockTime(m_cachedPosition);
+        }
 
-    GST_TRACE("videoPosition: %" GST_TIME_FORMAT ", audioPosition: %" GST_TIME_FORMAT, GST_TIME_ARGS(videoPosition), GST_TIME_ARGS(audioPosition));
+    } else {
+        if (gst_element_query(m_audioDecoder, query)) {
+            gst_query_parse_position(query, 0, (gint64*)&audioPosition);
+        }
 
-    position = max(videoPosition, audioPosition);
+        if (audioPosition == GST_CLOCK_TIME_NONE)
+            audioPosition = 0;
+        position = audioPosition;
+    }
 #else
     positionElement = m_pipeline.get();
 #endif
@@ -473,6 +477,7 @@ MediaTime MediaPlayerPrivateGStreamer::playbackPosition() const
         playbackPosition = m_seekTime;
 
     m_cachedPosition = playbackPosition;
+    m_lastQueryTime = now;
     return playbackPosition;
 }
 
diff --git a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
index b03d698b3ce..78da992bc9b 100644
--- a/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
+++ b/Source/WebCore/platform/graphics/gstreamer/MediaPlayerPrivateGStreamer.h
@@ -288,6 +288,10 @@ private:
 #endif
 #endif
     virtual bool isMediaSource() const { return false; }
+#if PLATFORM(BCM_NEXUS)
+    mutable GstElement* m_audioDecoder {nullptr };
+    mutable GstElement* m_videoDecoder {nullptr };
+#endif
 };
 }
 
